<h2>9.3. HÀM KHỞI TẠO VÀ VẤN ĐỀ THỪA KẾ</h3>
<p>Nhớ lại Mục 8.6 khi ta nói về cấu trúc bên trong của lớp con có chứa phần được thừa kế từ lớp cha, lớp Cow bọc ra ngoài cái lõi là phần Object mà nó được thừa kế. Nói cách khác, mỗi đối tượng lớp con không chỉ chứa các biến thực thể của chính nó mà còn chứa mọi thứ được hưởng từ lớp cha của nó. Mục này nói về việc khởi tạo phần được thừa kế đó.</p>
<h4>9.3.1. Gọi hàm khởi tạo của lớp cha</h4>
<p>Khi một đối tượng được tạo, nó được cấp phát bộ nhớ cho tất cả các biến thực thể của chính nó cũng như những thứ nó được thừa kế từ lớp cha, lớp ông, lớp cụ... cho đến lớp Object trên đỉnh cây thừa kế.</p>
<img src="Chapter9_3_image1.png" alt="">
<p>Tất cả các hàm khởi tạo trên trục thừa kế của một đối tượng đều phải được thực thi khi ta tạo mới đối tượng đó. Mỗi lớp tổ tiên của một lớp con, kể cả các lớp trừu tượng, đều có hàm khởi tạo. Tất cả các hàm khởi tạo đó được kích hoạt lần lượt mỗi khi một đối tượng của lớp con được tạo.</p>
<p>Lấy ví dụ Hippo trong cây thừa kế Animal. Một đối tượng Hippo mới chứa trong nó phần Animal, phần Animal đó lại chứa trong nó phần Object. Nếu ta muốn tạo một đối tượng Hippo, ta cũng phải khởi tạo phần Animal của đối tượng Hippo đó để nó có thể sử dụng được những gì được thừa kế từ Animal. Tương tự, để tạo phần Animal đó, ta cũng phải tạo phần Object chứa trong đó.</p>
<p>Khi một hàm khởi tạo chạy, nó lập tức gọi hàm khởi tạo của lớp cha. Khi hàm khởi tạo của lớp cha chạy, nó lập tức gọi hàm khởi tạo của lớp ông,... cứ như thế cho đến khi gặp hàm khởi tạo của Object. Quy trình đó được gọi là dây chuyền hàm khởi tạo (Constructor Chaining).</p>
<img src="Chapter9_3_image2.png" alt="">
<p>Ta minh họa dây chuyền hàm khởi tạo bằng ví dụ trong Hình 9.8. Trong ví dụ đó, mã chương trình TestHippo gọi lệnh <code>new Hippo()</code> để tạo đối tượng Hippo mới, lệnh này khởi động một dây chuyền hàm khởi tạo. Đầu tiên là <code>Hippo()</code> được kích hoạt, <code>Hippo()</code> gọi hàm khởi tạo của lớp cha – <code>Animal()</code>, đến lượt nó, <code>Animal()</code> gọi hàm khởi tạo của lớp ông,... cứ như thế cho đến khi gặp hàm khởi tạo của <code>Object()</code>. Sau khi <code>Object()</code> chạy xong, hoàn thành khởi tạo phần Object trong đối tượng Hippo, nó kết thúc và trả quyền điều khiển về cho nơi gọi nó – hàm khởi tạo <code>Animal()</code>. Hàm khởi tạo <code>Animal()</code> khởi tạo xong phần Animal của đối tượng Hippo rồi kết thúc, trả quyền điều khiển về cho nơi gọi nó – hàm khởi tạo <code>Hippo()</code>. <code>Hippo()</code> thực hiện công việc của mình rồi kết thúc. Đối tượng Hippo mới đã được khởi tạo xong.</p>
<p>Lưu ý rằng một hàm khởi tạo gọi hàm khởi tạo kia, nhưng trong Hình 9.8 hoàn toàn không có lệnh gọi <code>Animal()</code> từ trong mã của <code>Hippo()</code>, không có lệnh gọi <code>Object()</code> từ trong mã của <code>Animal()</code>. Một lần nữa, trình biên dịch đã làm công việc này thay cho lập trình viên, nó tự động điền lệnh <code>super()</code> vào ngay trước dòng đầu tiên của thân hàm khởi tạo. Việc này xảy ra đối với mỗi hàm khởi tạo mà tại đó lập trình viên không tự viết lời gọi đến hàm khởi tạo lớp cha. Còn đối với những hàm khởi tạo mà lập trình viên tự gọi <code>super</code>, lời gọi đó cũng phải là lệnh đầu tiên trong thân hàm.</p>
<p>Tại sao lời gọi <code>super()</code> phải là lệnh đầu tiên tại mỗi hàm khởi tạo? Đối tượng thuộc lớp con có thể phụ thuộc vào những gì nó được thừa kế từ lớp cha, do đó những gì được thừa kế nên được khởi tạo trước. Các phần thừa kế từ lớp cha phải được xây dựng hoàn chỉnh trước khi có thể xây dựng những phần của lớp con.</p>
<p>Lưu ý rằng cách duy nhất để gọi hàm khởi tạo lớp cha từ trong hàm khởi tạo lớp con là lệnh <code>super()</code> chứ không gọi đích danh tên hàm như <code>Animal()</code> hay <code>Object()</code>.</p>
<img src="Chapter9_3_image3.png" alt="">
<p>Lệnh gọi hàm khởi tạo lớp cha mà trình biên dịch sử dụng bao giờ cũng là <code>super()</code> không có đối số. Nhưng nếu ta tự gọi thì có thể dùng <code>super()</code> với đối số để gọi một hàm khởi tạo cụ thể trong các hàm khởi tạo chồng nhau của lớp cha.</p>
<h4>9.3.2. Truyền đối số cho hàm khởi tạo lớp cha</h3>
<p>Ta hình dung tình huống sau: con vật nào cũng có một cái tên, nên đối tượng Animal có biến thực thể <code>name</code>. Lớp Animal có một phương thức <code>getName()</code>, nó trả về giá trị của biến thực thể <code>name</code>. Biến thực thể đó được đánh dấu <code>private</code>, nhưng lớp con Hippo thừa kế phương thức <code>getName()</code>. Vấn đề ở đây là Hippo có phương thức <code>getName()</code> qua thừa kế, nhưng lại không có biến thực thể <code>name</code>. Hippo phải nhờ phần Animal của nó giữ biến <code>name</code> và trả về giá trị của <code>name</code> khi ai đó gọi <code>getName()</code> từ một đối tượng Hippo. Vậy khi một đối tượng Hippo được tạo, nó làm cách nào để gửi cho phần Animal giá trị cần khởi tạo cho <code>name</code>? Câu trả lời là: dùng giá trị đó làm đối số khi gọi hàm khởi tạo của Animal.</p>
<p>Ta thấy thân hàm <code>Hippo(String name)</code> trong ví dụ Hình 9.9 không làm gì ngoài việc gọi phương thức khởi tạo của lớp cha với danh sách tham số giống hệt. Có thể có người đọc thắc mắc vì sao phải viết hàm khởi tạo lớp con với nội dung chỉ như vậy. Trong khi nếu lớp con thừa kế lớp cha thì lớp con không cần cài lại cũng nghiễm nhiên được sử dụng phiên bản được thừa kế của lớp cha với danh sách tham số giống hệt, việc viết phương thức cài đè tại lớp con với nội dung chỉ gồm lời gọi tới phiên bản được thừa kế tại lớp cha là không cần thiết. Thực ra, tuy cùng là các phương thức khởi tạo và có cùng danh sách tham số, nhưng phương thức <code>Hippo(String name)</code> và <code>Animal(String name)</code> khác tên. <code>Hippo(String name)</code> không cài đè <code>Animal(String name)</code>. Tóm lại, lớp con không thừa kế phương thức khởi tạo của lớp cha.</p>
<img src="Chapter9_3_image4.png" alt="">


